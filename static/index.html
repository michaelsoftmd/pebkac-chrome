<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pebkac - Chrome NonAutomation Platform</title>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500&family=JetBrains+Mono:wght@300;400;500&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/style.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/lib/marked.umd.js"></script>
</head>
<body>
    <div class="container">
        <!-- Fixed top header -->
        <div class="fixed-header">
            <div class="pebkac-logo">
                <div class="pebkac-title">pebkac</div>
                <div class="pebkac-subtitle">Chrome NonAutomation Platform</div>
            </div>
            <div class="status-indicator">
                <span id="connection-status" class="status disconnected">Offline</span>
                <button class="theme-toggle" onclick="toggleTheme()">⚙</button>
            </div>
        </div>

        <div class="main-content">
            <div class="vnc-section">
                <div class="vnc-container">
                    <div id="vnc-placeholder" class="vnc-placeholder">
                        <div class="icon">▣</div>
                        <h3>Display Ready</h3>
                        <p>Dynamic resolution</p>
                        <p>Click "Start VNC" to connect to remote desktop</p>
                    </div>
                    <iframe
                        id="vnc-iframe"
                        src="about:blank">
                    </iframe>
                </div>
            </div>

            <div class="bottom-section">
                <div class="bottom-left">
                    <div class="main-tabs">
                        <button class="main-tab active" onclick="switchMainTab('chat')">Chat</button>
                        <button class="main-tab" onclick="switchMainTab('logs')">Logs</button>
                    </div>

                    <!-- Chat Tab Content -->
                    <div id="chat-tab" class="tab-content active">
                    <div class="chat-section">
                        <div class="chat-header">
                            <h3>pebkac Chat Interface</h3>
                            <div class="chat-controls">
                                <button class="btn btn-secondary" onclick="clearChat()">Clear Chat</button>
                                <span id="agent-status" class="agent-status">Ready</span>
                            </div>
                        </div>

                        <div id="chat-messages" class="chat-messages">
                            <div class="chat-prompt" id="initial-prompt">
                                > loading...
                            </div>
                        </div>

                        <div class="chat-input-container">
                            <textarea id="chat-input"
                                      class="chat-input"
                                      placeholder="Ask pebkac to browse the web..."
                                      rows="3"></textarea>
                            <button id="send-btn" class="btn btn-primary" onclick="sendMessage()">
                                Send
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Logs Tab Content -->
                <div id="logs-tab" class="tab-content">
                    <div class="logs-section">
                        <div class="log-controls">
                            <h3>System Logs</h3>
                            <div class="log-tabs">
                                <button class="log-tab active" onclick="switchLog('zendriver')">Browser</button>
                                <button class="log-tab" onclick="switchLog('llama-cpp-server')">AI Core</button>
                            </div>
                        </div>

                        <div id="log-viewer" class="log-viewer">
                            <div class="log-line info">pebkac Chrome NonAutomation Platform - Initializing...</div>
                            <div class="log-line info">System components loading...</div>
                            <div class="log-line info">Ready for operation</div>
                            <div class="log-line warning">Connecting to log streams...</div>
                        </div>
                    </div>
                </div>
                </div>

                <div class="controls-section">
                    <h3>System Controls</h3>
                    <div class="controls">
                        <button id="system-toggle" class="btn btn-boot" onclick="toggleSystem()">Boot System</button>
                        <button id="vnc-toggle" class="btn btn-primary" onclick="toggleVNC()">Start VNC</button>
                        <button id="copy-exports" class="btn btn-secondary" onclick="copyExports()">Copy Exports</button>
                        <button id="reset-containers" class="btn btn-danger" onclick="resetContainers()">DESTROY</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let vncActive = false;
        let currentLogSource = 'zendriver';
        let eventSource = null;
        let logBuffers = {
            'zendriver': [],
            'llama-cpp-server': []
        };
        const MAX_LOG_LINES = 1000;
        let retryCount = 0;
        let retryTimeout = null;
        let shouldReconnect = true;

        // Initialize on load
        window.addEventListener('load', () => {
            connectToLogs(currentLogSource);
        });

        // Handle window resize for VNC scaling
        window.addEventListener('resize', () => {
            if (vncActive) {
                const iframe = document.getElementById('vnc-iframe');
                if (iframe) {
                    // Trigger VNC to recalculate size
                    iframe.contentWindow?.postMessage({type: 'resize'}, '*');
                }
            }
        });

        // Clean up connections when page is closed or hidden
        window.addEventListener('beforeunload', () => {
            if (eventSource) {
                eventSource.close();
            }
            if (retryTimeout) {
                clearTimeout(retryTimeout);
            }
        });


        function toggleTheme() {
            // Simple theme toggle effect
            const title = document.querySelector('.pebkac-title');
            title.style.transform = 'rotate(-1deg) scale(1.02)';
            setTimeout(() => {
                title.style.transform = 'rotate(-1deg) scale(1)';
            }, 200);
        }

        function toggleVNC() {
            const iframe = document.getElementById('vnc-iframe');
            const placeholder = document.getElementById('vnc-placeholder');
            const button = document.getElementById('vnc-toggle');
            
            vncActive = !vncActive;
            
            if (vncActive) {
                // Calculate optimal resolution based on container size
                const container = iframe.parentElement;
                const maxWidth = Math.min(container.offsetWidth, 1920);
                const maxHeight = Math.min(container.offsetHeight, 1080);
                const minWidth = Math.max(640, maxWidth);
                const minHeight = Math.max(480, maxHeight);

                iframe.src = `http://localhost:6080/vnc.html?autoconnect=true&resize=scale&view_clip=false&quality=9&compression=0&reconnect=true&bell=false&shared=true`;
                iframe.classList.add('active');
                placeholder.style.display = 'none';
                button.textContent = 'Restart VNC';
                updateStatus('connecting');
                addLogLine(`VNC: Establishing connection (scaling to container size)...`, 'info');
                
                setTimeout(() => {
                    updateStatus('connected');
                    addLogLine('VNC: Connection established', 'info');
                    // Ensure iframe can receive focus and events
                    iframe.focus();
                }, 2000);

                // Add click handler to ensure iframe gets focus
                iframe.addEventListener('click', () => {
                    iframe.focus();
                });
            } else {
                iframe.src = 'about:blank';
                iframe.classList.remove('active');
                placeholder.style.display = 'flex';
                button.textContent = 'Start VNC';
                updateStatus('disconnected');
                addLogLine('VNC: Connection terminated', 'warning');
            }
        }

        function updateStatus(status) {
            const statusEl = document.getElementById('connection-status');
            statusEl.className = `status ${status}`;
            const statusMap = {
                'connected': 'Online',
                'connecting': 'Connecting',
                'disconnected': 'Offline'
            };
            statusEl.textContent = statusMap[status] || status;
        }


        async function resetContainers() {
            if (!confirm('DESTROY ALL DATA and recreate containers? This cannot be undone!')) {
                return;
            }

            const button = document.getElementById('reset-containers');
            button.disabled = true;
            button.textContent = 'Resetting...';
            addLogLine('SYSTEM: DESTROYING all data...', 'error');

            try {
                const response = await fetch('/api/control/reset', { method: 'POST' });
                const result = await response.json();

                if (result.status === 'success') {
                    addLogLine('SYSTEM: Destruction completed - all data destroyed', 'info');
                    showStopButton();
                } else {
                    addLogLine(`SYSTEM: Destroy failed - ${result.message}`, 'error');
                }
            } catch (error) {
                addLogLine(`SYSTEM: Error - ${error.message}`, 'error');
            } finally {
                button.disabled = false;
                button.textContent = 'DESTROY';
            }
        }

        async function toggleSystem() {
            const button = document.getElementById('system-toggle');
            const isRunning = button.textContent === 'Stop System';

            if (!isRunning) {
                // Starting system
                button.disabled = true;
                button.textContent = 'Starting...';

                // Re-enable log reconnection when starting services
                shouldReconnect = true;
                retryCount = 0;

                addLogLine('SYSTEM: Creating network infrastructure...', 'info');

                let startupSuccess = false;

                try {
                    // First create the network
                    const networkResponse = await fetch('/api/control/create-network', { method: 'POST' });
                    const networkResult = await networkResponse.json();

                    if (networkResult.status === 'success') {
                        addLogLine('SYSTEM: Network created successfully', 'info');
                    } else {
                        addLogLine('SYSTEM: Network already exists or created', 'warning');
                    }

                    addLogLine('SYSTEM: Starting service stack...', 'info');

                    // Then start the services
                    const response = await fetch('/api/control/compose-up', { method: 'POST' });
                    const result = await response.json();

                    if (result.status === 'success') {
                        addLogLine('SYSTEM: All services started successfully', 'info');
                        startupSuccess = true;
                    } else {
                        addLogLine(`SYSTEM: Startup failed - ${result.message || 'Unknown error'}`, 'error');
                    }
                } catch (error) {
                    addLogLine(`SYSTEM: Error - ${error.message}`, 'error');
                }

                // Always update button state
                if (startupSuccess) {
                    button.textContent = 'Stop System';
                    button.className = 'btn btn-danger';
                } else {
                    button.textContent = 'Boot System';
                    button.className = 'btn btn-boot';
                }

                button.disabled = false;

                // Verify actual system status after containers have time to start/stop
                setTimeout(() => checkSystemStatus(), 10000);
            } else {
                // Stopping system
                if (!confirm('Stop all containers? (Data will be preserved)')) {
                    return;
                }

                button.disabled = true;
                button.textContent = 'Stopping...';
                addLogLine('SYSTEM: Stopping containers (preserving data)...', 'warning');

                let stopSuccess = false;

                try {
                    const response = await fetch('/api/control/stop', { method: 'POST' });
                    const result = await response.json();

                    if (result.status === 'success') {
                        addLogLine('SYSTEM: Containers stopped - data preserved', 'info');
                        stopSuccess = true;
                    } else {
                        addLogLine(`SYSTEM: Stop failed - ${result.message || 'Unknown error'}`, 'error');
                    }
                } catch (error) {
                    addLogLine(`SYSTEM: Error - ${error.message}`, 'error');
                }

                // Always update button state
                if (stopSuccess) {
                    button.textContent = 'Boot System';
                    button.className = 'btn btn-boot';
                } else {
                    // If stop failed, assume system is still running
                    button.textContent = 'Stop System';
                    button.className = 'btn btn-danger';
                }

                button.disabled = false;

                // Verify actual system status after containers have time to start/stop
                setTimeout(() => checkSystemStatus(), 10000);
            }
        }

        async function copyExports() {
            const button = document.getElementById('copy-exports');
            try {
                button.disabled = true;
                button.textContent = 'Copying...';
                
                const response = await fetch('/api/export/copy-tmp', {
                    method: 'POST'
                });
                const data = await response.json();
                
                if (data.status === 'success') {
                    button.textContent = `Copied ${data.files.length} files`;
                    addLogLine(`Export copy successful: ${data.message}`, 'success');
                    if (data.files.length > 0) {
                        addLogLine(`Files copied: ${data.files.join(', ')}`, 'info');
                    }
                    setTimeout(() => {
                        button.textContent = 'Copy Exports';
                    }, 3000);
                } else {
                    addLogLine(`Export copy failed: ${data.error}`, 'error');
                    button.textContent = 'Copy Failed';
                    setTimeout(() => {
                        button.textContent = 'Copy Exports';
                    }, 3000);
                }
            } catch (error) {
                addLogLine(`Export copy error: ${error.message}`, 'error');
                button.textContent = 'Error';
                setTimeout(() => {
                    button.textContent = 'Copy Exports';
                }, 3000);
            } finally {
                button.disabled = false;
            }
        }

        function switchLog(source) {
            if (source === currentLogSource) return;

            document.querySelectorAll('.log-tab').forEach(tab => {
                tab.classList.remove('active');
            });

            event.target.classList.add('active');

            // Close existing connection
            if (eventSource) {
                eventSource.close();
            }

            // Switch to new source
            currentLogSource = source;

            // Clear display and restore logs for this source
            clearLogs();

            // Restore buffered logs for this source
            if (logBuffers[source] && logBuffers[source].length > 0) {
                const logViewer = document.getElementById('log-viewer');
                logBuffers[source].forEach(logHTML => {
                    logViewer.innerHTML += logHTML;
                });
                logViewer.scrollTop = logViewer.scrollHeight;
            } else {
                addLogLine(`Connecting to ${source} logs...`, 'info');
            }

            connectToLogs(source);
        }

        function connectToLogs(source) {
            if (eventSource) {
                eventSource.close();
            }

            let consecutiveFailures = 0;
            const maxConsecutiveFailures = 3;

            eventSource = new EventSource(`/api/logs/${source}`);

            eventSource.onmessage = (event) => {
                consecutiveFailures = 0;  // Reset on successful message
                const data = JSON.parse(event.data);

                // Detect if this is a new step/action
                const isNewStep = data.message.includes('Starting') ||
                                  data.message.includes('Executing') ||
                                  data.message.includes('Step') ||
                                  data.message.includes('CONNECTION:') ||
                                  data.message.includes('SYSTEM:') ||
                                  data.level === 'error';

                addLogLine(data.message, data.level || 'info', isNewStep);
            };

            eventSource.onerror = (error) => {
                if (retryTimeout) {
                    clearTimeout(retryTimeout);
                    retryTimeout = null;
                }

                consecutiveFailures++;

                // Stop retrying after too many consecutive failures
                if (consecutiveFailures >= maxConsecutiveFailures) {
                    eventSource.close();
                    addLogLine(`Container ${source} appears to be stopped`, 'info');
                    shouldReconnect = false;
                    return;
                }

                // Only show "Connecting" message on first failure
                if (consecutiveFailures === 1) {
                    addLogLine(`CONNECTION: Connecting to ${source}...`, 'info');
                }

                if (shouldReconnect) {
                    // Exponential backoff
                    const delay = Math.min(1000 * Math.pow(2, consecutiveFailures), 10000);
                    retryTimeout = setTimeout(() => {
                        if (shouldReconnect) {
                            connectToLogs(source);
                        }
                    }, delay);
                }
            };

            eventSource.onopen = () => {
                consecutiveFailures = 0;  // Reset on successful connection
                addLogLine(`CONNECTION: Connected to ${source} log stream`, 'info');
            };
        }

        function addLogLine(message, level = 'info', showTimestamp = false) {
            const viewer = document.getElementById('log-viewer');
            const line = document.createElement('div');
            line.className = `log-line ${level}`;

            // Only add timestamp for significant events
            if (showTimestamp) {
                const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
                line.textContent = `[${timestamp}] ${message}`;
            } else {
                line.textContent = message;
            }

            // Store log in source-specific buffer
            if (!logBuffers[currentLogSource]) {
                logBuffers[currentLogSource] = [];
            }

            logBuffers[currentLogSource].push(line.outerHTML);

            // Trim buffer if too large
            if (logBuffers[currentLogSource].length > MAX_LOG_LINES) {
                logBuffers[currentLogSource].shift();
                if (viewer.firstChild) {
                    viewer.removeChild(viewer.firstChild);
                }
            }

            viewer.appendChild(line);
            viewer.scrollTop = viewer.scrollHeight;
        }

        function clearLogs() {
            document.getElementById('log-viewer').innerHTML = '';
            logBuffer = [];
        }

        window.addEventListener('beforeunload', () => {
            if (eventSource) {
                eventSource.close();
            }
        });

        // Tab switching functionality
        function switchMainTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.main-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`.main-tab[onclick="switchMainTab('${tabName}')"]`).classList.add('active');

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(`${tabName}-tab`).classList.add('active');
        }

        // Chat functionality
        let conversationHistory = [];

        // Load chat history from localStorage on page load
        function loadChatHistory() {
            try {
                const saved = localStorage.getItem('pebkac_chat_history');
                if (saved) {
                    conversationHistory = JSON.parse(saved);

                    // Only restore if there's actual history
                    if (conversationHistory.length > 0) {
                        // Restore messages to UI
                        const messagesContainer = document.getElementById('chat-messages');
                        messagesContainer.innerHTML = '';

                        conversationHistory.forEach(msg => {
                            addMessage(msg.role, msg.content);
                        });
                    }
                }
            } catch (e) {
                console.error('Failed to load chat history:', e);
            }
        }

        // Save chat history to localStorage
        function saveChatHistory() {
            try {
                localStorage.setItem('pebkac_chat_history', JSON.stringify(conversationHistory));
            } catch (e) {
                console.error('Failed to save chat history:', e);
            }
        }

        async function sendMessage() {
            const input = document.getElementById('chat-input');
            const message = input.value.trim();

            if (!message) return;

            // Add user message to UI and history
            addMessage('user', message);
            conversationHistory.push({ role: 'user', content: message });
            saveChatHistory();
            input.value = '';

            setAgentStatus('thinking', 'Thinking...');

            try {
                const response = await fetch('http://localhost:8090/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: message,
                        history: conversationHistory.slice(0, -1)  // All history except current message
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                await streamResponse(response);

            } catch (error) {
                console.error('Chat error:', error);
                addMessage('assistant', `Connection error: ${error.message}`, true);
                setAgentStatus('error', 'Error');
            } finally {
                setAgentStatus('ready', 'Ready');
            }
        }

        async function streamResponse(response) {
            const reader = response.body.getReader();
            const decoder = new TextDecoder();

            let assistantMessage = '';
            let messageElement = null;

            try {
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (!line.trim() || !line.startsWith('data: ')) continue;

                        const data = line.substring(6);
                        if (data === '[DONE]') continue;

                        try {
                            const json = JSON.parse(data);

                            if (json.type === 'status') {
                                setAgentStatus('thinking', json.data);
                            } else if (json.type === 'content') {
                                assistantMessage += json.data;

                                if (!messageElement) {
                                    messageElement = addMessage('assistant', '');
                                }

                                // While streaming, just accumulate - don't format yet
                                messageElement.textContent = '< ' + assistantMessage;
                            } else if (json.type === 'done') {
                                // Stream complete - render as markdown
                                if (messageElement && assistantMessage) {
                                    const markdownContent = marked.parse(assistantMessage);
                                    messageElement.innerHTML = '< ' + markdownContent;
                                    messageElement.classList.add('markdown-output');
                                }
                                break;
                            } else if (json.type === 'error') {
                                addMessage('assistant', json.data, true);
                                conversationHistory.push({ role: 'assistant', content: `Error: ${json.data}` });
                                saveChatHistory();
                                return;
                            }

                        } catch (e) {
                            console.error('JSON parse error:', e);
                        }
                    }
                }
            } catch (e) {
                console.error('Stream error:', e);
                addMessage('assistant', `Stream error: ${e.message}`, true);
                return;
            }

            // Save assistant response to history
            if (assistantMessage) {
                conversationHistory.push({ role: 'assistant', content: assistantMessage });
                saveChatHistory();
            }
        }

        function addMessage(role, content, isError = false) {
            const messagesContainer = document.getElementById('chat-messages');

            // Remove prompt if present
            const prompt = messagesContainer.querySelector('.chat-prompt');
            if (prompt) prompt.remove();

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;

            const prefix = role === 'user' ? '> ' : '< ';

            if (role === 'assistant') {
                // All assistant messages rendered as markdown
                const markdownContent = marked.parse(content);
                messageDiv.innerHTML = prefix + markdownContent;
                messageDiv.classList.add('markdown-output');
            } else {
                // User messages stay plain text
                messageDiv.textContent = prefix + content;
            }

            if (isError) messageDiv.style.color = 'var(--accent-red)';

            messagesContainer.appendChild(messageDiv);

            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            return messageDiv;
        }

        function setAgentStatus(state, text) {
            const statusEl = document.getElementById('agent-status');
            statusEl.className = `agent-status ${state}`;
            statusEl.textContent = text;
        }

        function clearChat() {
            if (!confirm('Clear conversation history?')) return;

            // Clear conversation history
            conversationHistory = [];
            localStorage.removeItem('pebkac_chat_history');

            // Reset chat display
            const messagesContainer = document.getElementById('chat-messages');
            messagesContainer.innerHTML = `
                <div class="chat-prompt" id="initial-prompt">
                    > ${getRandomPrompt()}
                </div>
            `;

            // Reset agent status
            setAgentStatus('ready', 'Ready');
        }

        // Prompt suggestions
        const promptSuggestions = [
            'find the latest world news from three major news sites',
            'search amazon for wireless headphones',
            'what is the vine that reaches through brick',
            'search for wandering honeybees',
            'try your own suggestions',
            'summarise this page'
        ];

        function getRandomPrompt() {
            return promptSuggestions[Math.floor(Math.random() * promptSuggestions.length)];
        }

        function setInitialPrompt() {
            const promptElement = document.getElementById('initial-prompt');
            if (promptElement) {
                promptElement.textContent = '> ' + getRandomPrompt();
            }
        }

        // Handle Enter key in chat input and load chat history
        async function checkSystemStatus() {
            try {
                const response = await fetch('/api/control/status');
                const result = await response.json();

                const button = document.getElementById('system-toggle');
                if (result.running) {
                    button.textContent = 'Stop System';
                    button.className = 'btn btn-danger';
                } else {
                    button.textContent = 'Boot System';
                    button.className = 'btn btn-boot';
                }
            } catch (error) {
                console.error('Failed to check system status:', error);
            }
        }

        async function checkForRecentResult() {
            try {
                const response = await fetch('http://localhost:8090/api/agent/last-result');
                const data = await response.json();

                if (data.has_result && data.result) {
                    // Show original query
                    if (data.query) {
                        addMessage('user', data.query, false);
                    }

                    // Show result
                    addMessage('assistant', data.result, true);
                }
            } catch (error) {
                console.error('Failed to check for recent result:', error);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            setInitialPrompt();
            loadChatHistory();
            checkSystemStatus(); // Check status on page load
            checkForRecentResult(); // Check for recent completed results

            const input = document.getElementById('chat-input');
            if (input) {
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendMessage();
                    }
                });
            }
        });
    </script>
</body>
</html>